diff --git src/util/tptr.h src/util/tptr.h
index 6213b2e..94b2f78 100644
--- src/util/tptr.h
+++ src/util/tptr.h
@@ -19,6 +19,7 @@ Revision History:
 
 #pragma once
 
+#include <stdint.h>
 #include "util/machine.h"
 
 #define TAG_SHIFT        PTR_ALIGNMENT
diff --git src/math/lp/column_info.h src/math/lp/column_info.h
index 1dc0c60c7..05fb91152 100644
--- src/math/lp/column_info.h
+++ src/math/lp/column_info.h
@@ -41,6 +41,7 @@ class column_info {
     T           m_cost;
     unsigned    m_column_index;
 public:
+#if 0
     bool operator==(const column_info & c) const {
         return m_name == c.m_name &&
             m_lower_bound_is_set == c.m_lower_bound_is_set &&
@@ -55,6 +56,7 @@ public:
             m_column_index == c.m_column_index;
     }
     bool operator!=(const column_info & c) const { return !((*this) == c); }
+#endif
     void set_column_index(unsigned j) {
         m_column_index = j;
     }
diff --git src/math/lp/static_matrix.h src/math/lp/static_matrix.h
index f79ff36ac..8cbdb429a 100644
--- src/math/lp/static_matrix.h
+++ src/math/lp/static_matrix.h
@@ -79,7 +79,9 @@ public:
         ref(static_matrix & m, unsigned row, unsigned col):m_matrix(m), m_row(row), m_col(col) {}
         ref & operator=(T const & v) { m_matrix.set( m_row, m_col, v); return *this; }
 
+#if 0
         ref operator=(ref & v) { m_matrix.set(m_row, m_col, v.m_matrix.get(v.m_row, v.m_col)); return *this; }
+#endif
 
         operator T () const { return m_matrix.get_elem(m_row, m_col); }
     };
diff --git src/math/lp/static_matrix_def.h src/math/lp/static_matrix_def.h
index 76c1dec54..45c01d012 100644
--- src/math/lp/static_matrix_def.h
+++ src/math/lp/static_matrix_def.h
@@ -83,7 +83,7 @@ template <typename T, typename X> bool static_matrix<T, X>::pivot_row_to_row_giv
     return !rowii.empty();
 }
 
-
+#if 0
 // constructor that copies columns of the basis from A
 template <typename T, typename X>
 static_matrix<T, X>::static_matrix(static_matrix const &A, unsigned * /* basis */) :
@@ -94,6 +94,7 @@ static_matrix<T, X>::static_matrix(static_matrix const &A, unsigned * /* basis *
         for (auto & col : A.m_columns[m]) 
             set(col.var(), m, A.get_value_of_column_cell(col));
 }
+#endif
 
 template <typename T, typename X> void static_matrix<T, X>::clear() {
     m_vector_of_row_offsets.clear();
